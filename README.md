# Python
## Метрические алгоритмы классификации

__Гипотеза компактности__ утверждает, что схожим объектам соответствуют схожие ответы.

Метрические алгоритмы классификации основаны на __гипотезе компактности__,
которая говорит о том, что <u>схожим объектам соответствуют схожие ответы</u>.

Функцию, определяющую "схожесть" объектов называют __мерой близости__.
Эта функция определяется следующим образом:

![](http://latex.codecogs.com/svg.latex?%5Clarge%20%5Crho%3A%20%28X%20%5Ctimes%20X%29%20%5Crightarrow%20%5Cmathbb%7BR%7D)
(функция расстояния)

_Метрические алгоритмы классификации_ основаны на анализе сходства объектов с помощью
ранее описанной функции _расстояния_. Собственно, чем расстояние меньше, чем больше
объекты похожи друг на друга.

<u>Примечание</u>. Чтобы запустить алгоритм классификации на тестовой выборке необходимо
вызвать функцию `test()`.

### K ближайших соседей (KNN)

Для оценки близости объекта _u_ к классу _y_ алгоритм использует следующую
функцию:
![](http://latex.codecogs.com/svg.latex?%5Clarge%20W%28i%2C%20u%29%20%3D%20%5Bi%20%5Cleq%20k%5D)
, где _i_ обозначает порядок соседа по расстоянию к точке _u_.

Программно, функция веса реализуется следующим образом:
```
mc.KNN.w = function(i, k) +(i <= k)
```

Другими словами, алгоритм выбирает _k_ ближайших соседей и возвращает
тот класс, который среди выбранных встречается большее количество раз.

Программно алгоритм реализуется следующим образом:
```
mc.KNN = function(sortedDistances, k) {
    orderedDistances = 1:length(sortedDistances)
    names(orderedDistances) = names(sortedDistances)

    weights = mc.KNN.w(orderedDistances, k)
    weightsByClass = sapply(unique(names(weights)), mc.sumByClass, weights)

    bestClass = names(which.max(weightsByClass))
}
```
где `sortedDistances` – массив расстояний от неизвестной `u` до всех точек обучающей
выборки. `names(sortedDistances)` – наименование классов для каждой точки выборки.
